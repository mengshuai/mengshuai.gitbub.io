[{"title":"树形结构与扁平化结构互相转换、树形结构遍历","date":"2018-07-13T05:51:20.000Z","path":"2018/07/13/traverse-tree/","text":"123456789101112131415161718192021//将扁平的结构转换为树形结构function build(menuList)&#123; console.time(&apos;build&apos;) let temp = &#123;&#125;; let ans = &#123;&#125;; for(let i in menuList)&#123; temp[menuList[i].id] = menuList[i]; &#125; for(let i in temp)&#123; if(temp[i].parent_id) &#123; if(!temp[temp[i].parent_id].children) &#123; temp[temp[i].parent_id].children = new Object(); &#125; temp[temp[i].parent_id].children[temp[i].id] = temp[i]; &#125; else &#123; ans[temp[i].id] = temp[i]; &#125; &#125; console.timeEnd(&apos;build&apos;); return ans;&#125; 123456789101112131415161718192021222324// 非递归遍历树 与 将树扁平化function traverseTree(node) &#123; if (!node) &#123; return; &#125; var stack = [], result=[]; stack.push(node); var tmpNode; while (stack.length &gt; 0) &#123; tmpNode = stack.pop(); result.push(tmpNode); if (tmpNode.children &amp;&amp; tmpNode.children.length &gt; 0) &#123; var i = tmpNode.children.length - 1; for (i = tmpNode.children.length - 1; i &gt;= 0; i--) &#123; stack.push(tmpNode.children[i]); &#125; &#125; &#125; result.map(function(item,index,array)&#123; delete item.children; &#125;) console.log(result) return result;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript 浮点数陷阱及解法","date":"2017-12-25T05:55:01.000Z","path":"2017/12/25/js-floatcount-solution/","text":"JavaScript 浮点数陷阱及解法在javaScript浮点计算时会出现：0.1 + 0.2 = 0.30000000000000004，1 - 0.9 = 0.09999999999999998，其原因是因为js中数字都是以IEEE-754标准格式表示的，也就是所谓的二进制，当用二进制表示小数时会出现位数是无穷的（不只有js会有这个问题），比如 十进制 二进制 0.1 0.0001 1001 1001 1001 … 0.2 0.0011 0011 0011 0011 … 0.3 0.0100 1100 1100 1100 … 0.4 0.0110 0110 0110 0110 … 0.5 0.1 0.6 0.1001 1001 1001 1001 … 由十进制转换成二进制计算完再次转换为十进制的时候，就出现了浮点误差,下面给出解决方案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * @file 解决浮动运算问题，避免小数点后产生多位数和计算精度损失。 * 问题示例：2.3 + 2.4 = 4.699999999999999，1.0 - 0.9 = 0.09999999999999998 *//** * 把错误的数据转正 * strip(0.09999999999999998)=0.1 */function strip(num: number, precision = 12): number &#123; return +parseFloat(num.toPrecision(precision));&#125;/** * Return digits length of a number * @param &#123;*number&#125; num Input number */function digitLength(num: number): number &#123; // Get digit length of e const eSplit = num.toString().split(/[eE]/); const len = (eSplit[0].split(&apos;.&apos;)[1] || &apos;&apos;).length - (+(eSplit[1] || 0)); return len &gt; 0 ? len : 0;&#125;/** * 把小数转成整数，支持科学计数法。如果是小数则放大成整数 * @param &#123;*number&#125; num 输入数 */function float2Fixed(num: number): number &#123; if (num.toString().indexOf(&apos;e&apos;) === -1) &#123; return Number(num.toString().replace(&apos;.&apos;, &apos;&apos;)); &#125; const dLen = digitLength(num); return dLen &gt; 0 ? num * Math.pow(10, dLen) : num;&#125;/** * 检测数字是否越界，如果越界给出提示 * @param &#123;*number&#125; num 输入数 */function checkBoundary(num: number) &#123; if (num &gt; Number.MAX_SAFE_INTEGER || num &lt; Number.MIN_SAFE_INTEGER) &#123; console.warn(`$&#123;num&#125; is beyond boundary when transfer to integer, the results may not be accurate`); &#125;&#125;/** * 精确乘法 */function times(num1: number, num2: number, ...others: number[]): number &#123; if (others.length &gt; 0) &#123; return times(times(num1, num2), others[0], ...others.slice(1)); &#125; const num1Changed = float2Fixed(num1); const num2Changed = float2Fixed(num2); const baseNum = digitLength(num1) + digitLength(num2); const leftValue = num1Changed * num2Changed; checkBoundary(leftValue); return leftValue / Math.pow(10, baseNum);&#125;/** * 精确加法 */function plus(num1: number, num2: number, ...others: number[]): number &#123; if (others.length &gt; 0) &#123; return plus(plus(num1, num2), others[0], ...others.slice(1)); &#125; const baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2))); return (times(num1, baseNum) + times(num2, baseNum)) / baseNum;&#125;/** * 精确减法 */function minus(num1: number, num2: number, ...others: number[]): number &#123; if (others.length &gt; 0) &#123; return minus(minus(num1, num2), others[0], ...others.slice(1)); &#125; const baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2))); return (times(num1, baseNum) - times(num2, baseNum)) / baseNum;&#125;/** * 精确除法 */function divide(num1: number, num2: number, ...others: number[]): number &#123; if (others.length &gt; 0) &#123; return divide(divide(num1, num2), others[0], ...others.slice(1)); &#125; const num1Changed = float2Fixed(num1); const num2Changed = float2Fixed(num2); checkBoundary(num1Changed); checkBoundary(num2Changed); return times((num1Changed / num2Changed), Math.pow(10, digitLength(num2) - digitLength(num1)));&#125;/** * 四舍五入 */function round(num: number, ratio: number): number &#123; const base = Math.pow(10, ratio); return divide(Math.round(times(num, base)), base);&#125;export &#123; strip, plus, minus, times, divide, round, digitLength, float2Fixed &#125;;export default &#123; strip, plus, minus, times, divide, round, digitLength, float2Fixed &#125;; 使用方式: 使用npm包 1npm install number-precision --save 123456NP.strip(num) // strip a number to nearest right numberNP.plus(num1, num2, num3, ...) // addition, num + num2 + num3, two numbers is required at least.NP.minus(num1, num2, num3, ...) // subtraction, num1 - num2 - num3NP.times(num1, num2, num3, ...) // multiplication, num1 * num2 * num3NP.divide(num1, num2, num3, ...) // division, num1 / num2 / num3NP.round(num, ratio) // round a number based on ratio 123456789import NP from &apos;number-precision&apos;NP.strip(0.09999999999999998); // =0.1NP.plus(0.1, 0.2); // =0.3 not 0.30000000000000004NP.plus(2.3, 2.4); // =4.7 not 4.699999999999999NP.minus(1.0, 0.9); // =0.1 not 0.09999999999999998NP.times(3, 0.3); // =0.9 not 0.8999999999999999NP.times(0.362, 100); // = 36.2, not 36.199999999999996NP.divide(1.21, 1.1); // =1.1 not 1.0999999999999999NP.round(0.105, 2); // =0.11 not 0.1","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"js获取url中参数","date":"2017-12-25T03:35:21.000Z","path":"2017/12/25/get-url-parameter/","text":"js获取url中参数采用正则表达式获取123456789101112function GetQueryString(name)&#123; var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;); var r = window.location.search.substr(1).match(reg); if(r!=null)return unescape(r[2]); return null;&#125; // 调用方法alert(GetQueryString(&quot;参数名1&quot;));alert(GetQueryString(&quot;参数名2&quot;));alert(GetQueryString(&quot;参数名3&quot;));","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"多行字符串变相实现","date":"2017-05-16T07:35:40.000Z","path":"2017/05/16/multiline-string/","text":"主要是利用函数的toString()方法实现。 函数的toString方法返回函数的源码。 123456789101112function f() &#123; a(); b(); c();&#125;f.toString()// function f() &#123;// a();// b();// c();// &#125; 函数内部的注释也可以返回。12345678910function f() &#123;/* 这是一个 多行注释*/&#125;f.toString()// &quot;function f()&#123;/*// 这是一个// 多行注释// */&#125;&quot; 利用这一点，可以变相实现多行字符串。 12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split(&apos;\\n&apos;); return arr.slice(1, arr.length - 1).join(&apos;\\n&apos;);&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// &quot; 这是一个// 多行注释&quot;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript 调试常见报错以及修复方法","date":"2017-04-01T09:29:26.000Z","path":"2017/04/01/debugger-err-fix/","text":"（看到一篇调试JS很有用的文章，收藏一下） JavaScript 调试是一场噩梦：首先给出的错误非常难以理解，其次给出的行号不总有帮助。有个查找错误含义，及修复措施的列表，是不是很有用？ 以下是奇怪的 JavaScript 错误列表。同样的错误，不同的浏览器会给出不同的消息，因此有一些不同的例子。 如何读懂错误？首先，让我们快速看下错误信息的结构。理解结构有助于理解错误，如果遇到列表之外的错误会减少麻烦。 Chrome 中典型的错误像这样：1Uncaught TypeError: undefined is not a function 错误的结构如下： 1、Uncaught TypeError： 这部分信息通常不是很有用。Uncaught 表示错误没有被 catch 语句捕获，TypeError 是错误的名字。 2、undefined is not a function: 这部分信息，你必须逐字阅读。比如这里表示代码尝试使用 undefined ，把它当做一个函数。 其它基于 webkit 的浏览器，比如 Safari ，给出的错误格式跟 Chrome 很类似。Firefox 也类似，但是不总包含第一部分，最新版本的 IE 也给出比 Chrome 简单的错误 - 但是在这里，简单并不总代表好。 以下是真正的错误。 Uncaught TypeError: undefined is not a function相关错误：number is not a function, object is not a function, string is not a function, Unhandled Error: ‘foo’ is not a function, Function Expected 当尝试调用一个像方法的值时，这个值并不是一个方法。比如： 12var foo = undefined;foo(); 如果你尝试调用一个对象的方法时，你输错了名字，这个典型的错误很容易发生。1var x = document.getElementByID(&apos;foo&apos;); 由于对象的属性不存在，默认是 undefined ，以上代码将导致这个错误。尝试调用一个像方法的数字，number is not a function 错误出现。 如何修复错误：确保方法名正确。这个错误的行号将指出正确的位置。 Uncaught ReferenceError: Invalid left-hand side in assignment相关错误：Uncaught exception: ReferenceError: Cannot assign to ‘functionCall()’, Uncaught exception: ReferenceError: Cannot assign to ‘this’ 尝试给不能赋值的东西赋值，引起这个错误。 这个错误最常见的例子出现在 if 语句使用：1if(doSomething() = &apos;somevalue&apos;) 此例中，程序员意外地使用了单个等号，而不是双等号。“left-hand side in assignment” 提及了等号左手边的部分，因此你可以看到以上例子，左手边包含不能赋值的东西，导致这个错误。 如何修复错误：确保没有给函数结果赋值，或者给 this 关键字赋值。 Uncaught TypeError: Converting circular structure to JSON相关错误：`Uncaught exception: TypeError: JSON.stringify: Not an acyclic Object, TypeError: cyclic object value, Circular reference in value argument not supported 把循环引用的对象，传给 JSON.stringify 总会引起错误。 1234var a = &#123; &#125;;var b = &#123; a: a &#125;;a.b = b;JSON.stringify(a); 由于以上的a和b循环引用彼此，结果对象无法转换成 JSON。 如何修复错误：移除任何想转换成 JSON 的对象中的循环引用。 Unexpected token ;相关错误：Expected ), missing ) after argument list JavaScript 解释器预期的东西没有被包含。不匹配的圆括号或方括号通常引起这个错误。 错误信息可能有所不同 - “Unexpected token ]” 或者 “Expected {” 等。 如何修复错误：有时错误出现的行号并不准确，因此很难修复。 { } ( ) 这几个符号不配对常常导致出错。检查所有的圆括号和方括号是否配对。行号指出的不仅是问题字符。 Unexpected / 跟正则表达式有关。此时行号通常是正确的。 Unexpected ; 对象或者数组字面量里面有个 ; 通常引起这个错误，或者函数调用的参数列表里有个分号。此时的行号通常也是正确的。 Uncaught SyntaxError: Unexpected token ILLEGAL相关错误：Unterminated String Literal, Invalid Line Terminator 一个字符串字面量少了结尾的引号。 如何修复错误：确保所有的字符串都有结束的引号。 Uncaught TypeError: Cannot read property ‘foo’ of null, Uncaught TypeError: Cannot read property ‘foo’ of undefined相关错误：TypeError: someVal is null, Unable to get property ‘foo’ of undefined or null reference 尝试读取 null 或者 undefined ，把它当成了对象。例如：12var someVal = null;console.log(someVal.foo); 如何修复错误：通常由于拼写错误导致。检查错误指出的行号附近使用的变量名是否正确。 Uncaught TypeError: Cannot set property ‘foo’ of null, Uncaught TypeError: Cannot set property ‘foo’ of undefined相关错误：TypeError: someVal is undefined, Unable to set property ‘foo’ of undefined or null reference尝试写入 null 或者 undefined ，把它当成了一个对象。例如：12var someVal = null;someVal.foo = 1; 如何修复错误：也是由于拼写错误所致。检查错误指出的行号附近的变量名。 Uncaught RangeError: Maximum call stack size exceeded相关错误：Related errors: Uncaught exception: RangeError: Maximum recursion depth exceeded, too much recursion, Stack overflow 通常由程序逻辑 bug 引起，导致函数的无限递归调用。 如何修复错误：检查递归函数中可能导致无限循环 的 bug 。 Uncaught URIError: URI malformed相关错误：URIError: malformed URI sequence 无效的 decodeURIComponent 调用所致。 如何修复错误：按照错误指出的行号，检查 decodeURIComponent 调用，它是正确的。 XMLHttpRequest cannot load http://some/url/. No ‘Access-Control-Allow-Origin’ header is present on the requested resource相关错误：Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://some/url/ 错误肯定是使用 XMLHttpRequest 引起的。 如何修复错误：确保请求的 URL 是正确的，它遵循同源策略 。最好的方法是从代码中找到错误信息指出的 URL 。 InvalidStateError: An attempt was made to use an object that is not, or is no longer, usable相关错误：InvalidStateError, DOMException code 11 代码调用的方法在当前状态无法调用。通常由 XMLHttpRequest 引起，在方法准备完毕之前调用它会引起错误。12var xhr = new XMLHttpRequest();xhr.setRequestHeader(&apos;Some-Header&apos;, &apos;val&apos;); 这时就会出错，因为 setRequestHeader 方法只能在 xhr.open 方法之后调用。 如何修复错误：查看错误指出的行号，确保代码运行的时机正确，或者在它（例如 xhr.open）之前添加了不必要的调用 原文Jani Hartikainen - 《JavaScript Errors and How to Fix Them》翻译出处：涂鸦码农 - JavaScript 错误以及如何修复","tags":[{"name":"转载","slug":"转载","permalink":"http://yoursite.com/tags/转载/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JavaScript深拷贝浅拷贝问题","date":"2017-04-01T02:15:07.000Z","path":"2017/04/01/shallow-deep-copy/","text":"浅拷贝和深拷贝只针对Object、Array。 浅拷贝：浅拷贝是拷贝引用，拷贝后的引用都是指向同一个对象的实例，彼此之间的操作会互相影响（在内存中指向同一地址）深拷贝：在内存中重新分配地址，将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。（拷贝后彼此之间互不影响） 浅拷贝拷贝原对象的引用最简单的浅拷贝12345var obj = &#123; a:1, arr: [2,3] &#125;;var obj1 = obj;console.log(obj === obj1); // trueobj.a = 5;console.log(obj1.a) // 5 源对象拷贝实例，其属性对象拷贝引用。这种情况，外层源对象是拷贝实例，如果其属性元素为复杂杂数据类型时，内层元素拷贝引用。对源对象直接操作，不影响两外一个对象，但是对其属性操作时候，会改变两外一个对象的属性的只。常用方法为：Array.prototype.slice(), Array.prototype.concat(), jQury的$.extend({},obj)，例：Underscore —— _.clone()就是 12345var a = [&#123;c:1&#125;, &#123;d:2&#125;];var b = a.slice();console.log(a === b); // 输出false，说明外层数组拷贝的是实例a[0].c = 3;console.log(b[0].c); // 输出 3，说明其元素拷贝的是引用 深拷贝深拷贝后，两个对象，包括其内部的元素互不干扰。常见方法有JSON.parse(),JSON.stringify()，jQury的$.extend(true,{},obj)，lodash的.cloneDeep和.clone(value, true)。例：123456789101112131415161718192021var obj = &#123; a:1, arr: [2,3] &#125;;//方法一:借助 JSON 全局对象（兼容IE8+）var obj1 = JSON.parse(JSON.stringify(obj));//验证console.log(obj === obj1) //输出falseobj.a = 5;console.log(obj1.a) //输出1//方法二:利用递归var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; for(var i in obj)&#123; newobj[i] = typeof obj[i] === &apos;object&apos; ? cloneObj(obj[i]) : obj[i]; &#125; return newobj;&#125;;var obj2 = cloneObj(obj);//方法三：jquery的$.extend(true,&#123;&#125;,obj)（但jQuery不能正确处理Int16Array的深复制！！！）var obj3 = $.extend(true, &#123;&#125;, obj);//方法四：lodash的_.cloneDeep和_.clone(value, true)var obj4 = _.cloneDeep(obj); 通用方法可以将方法一和方法二整合成一个深拷贝的通用方法123456789101112131415var cloneObj = function(obj)&#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if(typeof obj !== &apos;object&apos;)&#123; return; &#125; else if(window.JSON)&#123; str = JSON.stringify(obj), //系列化对象 newobj = JSON.parse(str); //还原 &#125; else &#123; for(var i in obj)&#123; newobj[i] = typeof obj[i] === &apos;object&apos; ? cloneObj(obj[i]) : obj[i]; //递归方法实现，对于IE7以及IE8的兼容模式window未内置JSON对象 &#125; &#125; return newobj;&#125;;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]}]